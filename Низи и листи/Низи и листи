1.
За дадена низа од N цели броеви, да се избришат елементите со вредност помала од просекот на сите елементи во низата. На пример за низата 1, 2, 3, 4, 5 просекот е (1 + 2 + 3 + 4 + 5) / 5 = 15 / 5 = 3, 
што значи треба да се избришат елементите 1 и 2, што значи низата после оваа трансформација ќе биде 3, 4, 5.
Влез: Првиот број од влезот е бројот на елементи во низата N, а потоа во следниот ред се дадени самите елементи одделени со празно место.
Излез: Низата пред и после направената трансформација.

/

For a given array with N integers, all the elements that are lower than the average of the whole array need to be deleted. For example for the array 1, 2, 3, 4, 5 the average is (1 + 2 + 3 + 4 + 5) / 5 = 15 / 5 = 3 which means that the elements 1 and 2 should be deleted, so the array after the transformation will be 3, 4, 5.
Input: The first number in the input is the number of integers in the array N, then in the next line the elements are given, separated by spaces.

Output: The array before and after the transformation.

For example:
Input 	
5
1 2 3 4 5

Result
{1,2,3,4,5}
{3,4,5}
PRVO RESENIE:
import java.util.Scanner;
public class Main {
    static int prosek(int [] array,int n){
        float sum=0;
        for (int i = 0; i <n ; i++) {
            sum+=array[i];
        }
        int average=Math.round(sum/n);
        return average;
    }
    public static void main(String[] args) {
Scanner scanner=new Scanner(System.in);
int n=scanner.nextInt();
int[] array=new int[n];
        for (int i = 0; i < n; i++) {
            array[i]=scanner.nextInt();
        }
        System.out.print("{");
        for (int i = 0; i < n; i++) {
            System.out.print(array[i]);
            if (i<n-1) System.out.print(",");
        }
        System.out.print("}");

        int average=prosek(array,n);
        ArrayList<Integer> newArray=new ArrayList<>();
        for (int i = 0; i <n ; i++) {
            if (array[i]>=average){
                newArray.add(array[i]);
            }
        }
        System.out.println();
        System.out.print("{");
        for (int i = 0; i < newArray.size(); i++) {
            System.out.print(newArray.get(i));
            if (i<newArray.size()-1) System.out.print(",");
        }
        System.out.print("}");
    }


}

DRUGO RESENIE:

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class DeleteInArray {
    public static void main( String[] args){
        Scanner scanner=new Scanner(System.in);
        int n=scanner.nextInt();
        int[] array=new int[n];
        for (int i = 0; i < n; i++) {
            array[i]=scanner.nextInt();
        }
        double sum=0;
        for (int num:array){
            sum+=num;
        }
        double avg=sum/n;
        List<Integer>filteredArray=new ArrayList<>();
        for (int num:array){
            if (num>=avg){
                filteredArray.add(num);
            }
        }
        System.out.print("{");
        for (int i = 0; i <n ; i++) {
            System.out.print(array[i]);
            if (i<array.length-1){
                System.out.print(",");
            }
        }
        System.out.print("}");
        System.out.println();

        System.out.print("{");
        for (int i = 0; i <filteredArray.size(); i++) {
            System.out.print(filteredArray.get(i));
            if (i<filteredArray.size()-1){
                System.out.print(",");
            }
        }
        System.out.print("}");
    }

}

2.
Дадена е еднострана поврзана листа чии што јазли содржат по еден String. Дополнително, даден е и уште еден природен број L. Од дадената листа потребно е да се избрише секој јазел којшто содржи String со должина помала од L.
Влез: Во првиот ред од влезот е даден бројот на елементи во листата - N, па во следните N редови се дадени самите елементи (String-ови) од листата. На крај, во последниот ред е даден бројот L. 
Излез: На излез треба да се испечати листата пред и после промената.
/
You are given a single linked list with String nodes. Additionally, you are given one more integer L. You need to delete every node from the list that contains a String with less than L characters.
Input: In the first line from the input the number of elements in the list is given - N, and then in the next N lines the elements themselves. In the last line, the integer L is given.
Output: The list before and after the transformation

For example:
Input 	

3
Sky
Blue
Cloud
5

Result
Sky->Blue->Cloud
Cloud


public class SLLDeleteLessThanN {

    public static class SLLNode<E> {
        E element;
        SLLNode<E> succ;

        public SLLNode(E element, SLLNode<E> succ) {
            this.element = element;
            this.succ = succ;
        }
    }

    public static class SLL<E> {
        SLLNode<E> first;

        public void insertFirst(E o) {
            SLLNode<E> newNode = new SLLNode<>(o, first);
            first = newNode;
        }

        public void insertLast(E o) {
            if (first != null) {
                SLLNode<E> tmp = first;
                while (tmp.succ != null)
                    tmp = tmp.succ;
                tmp.succ = new SLLNode<>(o, null);
            } else {
                insertFirst(o);
            }
        }

        SLLNode<E> getFirst() {
            return first;
        }

        public void deleteLessThanL(int L) {
           
            while (first != null && ((String) first.element).length() < L) {
                first = first.succ;
            }

           
            SLLNode<E> current = first;
            while (current != null && current.succ != null) {
                if (((String) current.succ.element).length() < L) {
                    current.succ = current.succ.succ; // Skip the node
                } else {
                    current = current.succ; // Move to the next node
                }
            }
        }

        public void printList() {
            SLLNode<E> current = first;
            while (current != null) {
                System.out.print(current.element);
                if (current.succ != null) {
                    System.out.print("->");
                }
                current = current.succ;
            }
            
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int N = scanner.nextInt();
        SLL<String> list = new SLL<>();

        for (int i = 0; i < N; i++) {
            list.insertLast(scanner.next());
        }

        int L = scanner.nextInt();

      
        list.printList();

        list.deleteLessThanL(L);
System.out.println();
        list.printList();

        scanner.close();
    }
}
3.
Дадена е еднострана поврзана листа чии што јазли содржат по еден String. Дополнително, даден е и уште еден природен број L. Во дадената листа после секој јазол којшто содржи String со должина L да се вметне нов јазол со
вредност "Target".
Влез: Во првиот ред од влезот е даден бројот на елементи во листата - N, па во следните N редови се дадени самите елементи (String-ови) од листата. На крај, во последниот ред е даден бројот L. 
Излез: На излез треба да се испечати листата пред и после промената.
/

You are given a single linked list with String nodes. Additionally, you are given one more integer L. You need to insert a new node with value "Target" after each node that contains a String with exactly L characters in the list.
Input: In the first line from the input the number of elements in the list is given - N, and then in the next N lines the elements themselves. In the last line, the integer L is given.
Output: The list before and after the transformation
For example:
Input 	

3
Sky
Blue
Cloud
5

Result
Sky->Blue->Cloud
Sky->Blue->Cloud->Target

import java.util.Scanner;

public class SLLInsertAfterTarget {

    public static class SLLNode<E> {
        E element;
        SLLNode<E> succ;

        public SLLNode(E element, SLLNode<E> succ) {
            this.element = element;
            this.succ = succ;
        }
    }

    public static class SLL<E> {
        SLLNode<E> first;

        public void insertLast(E o) {
            if (first != null) {
                SLLNode<E> tmp = first;
                while (tmp.succ != null)
                    tmp = tmp.succ;
                tmp.succ = new SLLNode<>(o, null);
            } else {
                first = new SLLNode<>(o, null);
            }
        }

        public void insertAfterTarget(E target, int L) {
            SLLNode<E> current = first;
            while (current != null) {
                if (((String) current.element).length() == L) {
                    SLLNode<E> newNode = new SLLNode<>(target, current.succ);
                    current.succ = newNode;
                    current = newNode.succ; // Move past the new node
                } else {
                    current = current.succ;
                }
            }
        }

        public void printList() {
            SLLNode<E> current = first;
            while (current != null) {
                System.out.print(current.element);
                if (current.succ != null) {
                    System.out.print("->");
                }
                current = current.succ;
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the number of elements in the list
        int N = scanner.nextInt();
        SLL<String> list = new SLL<>();

        // Read the elements of the list
        for (int i = 0; i < N; i++) {
            list.insertLast(scanner.next());
        }

        // Read the value of L
        int L = scanner.nextInt();

        // Print the list before transformation
        list.printList();

        // Perform the transformation
        list.insertAfterTarget("Target", L);

        // Print the list after transformation
        list.printList();

        scanner.close();
    }
}
4.
Дадена е еднострана поврзана листа чии што јазли содржат по еден String. Дополнително, даден е и уште еден природен број L. Во дадената листа пред секој јазол којшто содржи String со должина поголема од L
да се вметне нов јазол со вредност "Outlier".
Влез: Во првиот ред од влезот е даден бројот на елементи во листата - N, па во следните N редови се дадени самите елементи (String-ови) од листата. На крај, во последниот ред е даден бројот L. 
Излез: На излез треба да се испечати листата пред и после промената.
/
You are given a single linked list with String nodes. Additionally, you are given one more integer L. You need to insert a new node with value "Outlier" before each node that contains a String with more than L characters in the list.
Input: In the first line from the input the number of elements in the list is given - N, and then in the next N lines the elements themselves. In the last line, the integer L is given.
Output: The list before and after the transformation
For example:
Input 	

3
Sky
Blue
Cloud
5

Result
Sky->Blue->Cloud
Sky->Blue->Cloud

1
Hello
4

Result
Hello
Outlier->Hello

3
Big
Elephant
Small
6

Result
Big->Elephant->Small
Big->Outlier->Elephant->Small

import java.util.*;

import java.util.Scanner;

// Node class for singly linked list
class SLLNode<E> {
    public E element;
    public SLLNode<E> succ;

    public SLLNode(E element, SLLNode<E> succ) {
        this.element = element;
        this.succ = succ;
    }
}

// Singly Linked List class
class SLL<E> {
    private SLLNode<E> first;

    public SLL() {
        this.first = null;
    }

    public SLLNode<E> getFirst() {
        return first;
    }

    public void insertLast(E element) {
        if (first == null) {
            first = new SLLNode<>(element, null);
        } else {
            SLLNode<E> temp = first;
            while (temp.succ != null) {
                temp = temp.succ;
            }
            temp.succ = new SLLNode<>(element, null);
        }
    }

    public void insertBefore(E element, SLLNode<E> node) {
        if (first == null || first == node) {
            first = new SLLNode<>(element, first);
            return;
        }

        SLLNode<E> temp = first;
        while (temp.succ != null && temp.succ != node) {
            temp = temp.succ;
        }

        if (temp.succ == node) {
            temp.succ = new SLLNode<>(element, node);
        }
    }

   @Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    SLLNode<E> temp = first;

    while (temp != null) {
        sb.append(temp.element);
        if (temp.succ != null) { // Only add "->" if there is a next element
            sb.append("->");
        }
        temp = temp.succ;
    }

    return sb.toString();
}

}

// Main program class
public class prog {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        SLL<String> list = new SLL<>();

        // Reading elements into the linked list
        for (int i = 0; i < n; i++) {
            String val = input.next();
            list.insertLast(val);
        }

        int length = input.nextInt();
        System.out.println(list);

        SLLNode<String> node = list.getFirst();

        // Insert "Outlier" before nodes with element length > length
        while (node != null) {
            if (node.element.length() > length) {
                list.insertBefore("Outlier", node);
            }
            node = node.succ;
        }

        System.out.println(list);
        input.close();
    }
}



5.
Дадена е еднострана поврзана листа чии што јазли содржат по еден String. Дополнително, даден е и уште еден природен број L. Во дадената листа потребно е сите јазли коишто содржат String со должина L да се
поместат на крај на листата, задржувајќи го и оригиналниот распоред на елементите.
Влез: Во првиот ред од влезот е даден бројот на елементи во листата - N, па во следните N редови се дадени самите елементи (String-ови) од листата. На крај, во последниот ред е даден бројот L. 
Излез: На излез треба да се испечати листата пред и после промената.
/

You are given a single linked list with String nodes. Additionally, you are given one more integer L. You need to move all nodes from the list that contain a String with exactly L characters to the end of the list, keeping the original order of elements as well.
Input: In the first line from the input the number of elements in the list is given - N, and then in the next N lines the elements themselves. In the last line, the integer L is given.
Output: The list before and after the transformation
For example:
Input 	

3
Sky
Blue
Cloud
5

	
Result
Sky->Blue->Cloud
Sky->Blue->Cloud

4
Apple
Banana
Pear
Watermelon
6

Result
Apple->Banana->Pear->Watermelon
Apple->Pear->Watermelon->Banana
import java.util.ArrayList;
import java.util.Scanner;





public class Main {
    public static class Node {
        String element;
        Node succ;

        public Node(String element) {
            this.element = element;
            this.succ = null;
        }
    }



    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Read input
        int n = sc.nextInt();  // Number of elements in the list
        sc.nextLine();  // Consume newline
        Node head = null, tail = null;

        for (int i = 0; i < n; i++) {
            String data = sc.nextLine();
            Node newNode = new Node(data);
            if (head == null) {
                head = newNode;
                tail = head;
            } else {
                tail.succ = newNode;
                tail = newNode;
            }
        }

        int l = sc.nextInt();  // The integer L


        printList(head);

        // Transform the list
        head = transformList(head, l);

        printList(head);

        sc.close();
    }
    private static Node transformList(Node head, int l){
        if (head==null){
            return null ;
        }

        Node dummyHead=new Node("");
dummyHead.succ=head;
        Node current=dummyHead;

        Node tmpHead=new Node("");
        Node tmpTail=tmpHead;

while (current!=null){
    if (current.succ.element.length()==l){
Node moveNode=current.succ;
current.succ=current.succ.succ;
moveNode.succ=null;
tmpTail.succ=moveNode;
tmpTail=moveNode;
    }else{
        current=current.succ;
    }
}
current.succ=dummyHead.succ;
return dummyHead.succ;
    }
    private static void printList(Node head) {
        Node current = head;
        while (current != null) {
            System.out.print(current.succ + (current.succ != null ? "->" : ""));
            current = current.succ;
        }
        System.out.println();
    }
}

6.
Дадена е еднострана поврзана листа чии што јазли содржат по еден String. Дополнително, даден е и уште еден природен број L. Од дадената листа потребно е да се најде последниот јазел којшто содржи String со должина L 
и да се премести на почеток на листата.
Влез: Во првиот ред од влезот е даден бројот на елементи во листата - N, па во следните N редови се дадени самите елементи (String-ови) од листата. На крај, во последниот ред е даден бројот L. 
Излез: На излез треба да се испечати листата пред и после промената.
/
You are given a single linked list with String nodes. Additionally, you are given one more integer L. You need to find the last node that contains a String with exactly L characters, and move it to the front of the list.
Input: In the first line from the input the number of elements in the list is given - N, and then in the next N lines the elements themselves. In the last line, the integer L is given.
Output: The list before and after the transformation

Input 	

3
Sky
Blue
Cloud
5

Result
Sky->Blue->Cloud
Cloud->Sky->Blue
import java.util.Scanner;

class SLLNode<E> {
    E element;
    SLLNode<E> succ;

    public SLLNode(E element, SLLNode<E> succ) {
        this.element = element;
        this.succ = succ;
    }
}

class SLL<E> {
    private SLLNode<E> first;

    public SLL() {
        this.first = null;
    }

    public SLLNode<E> getFirst() {
        return first;
    }

    public void insertLast(E element) {
        SLLNode<E> newNode = new SLLNode<>(element, null);
        if (first == null) {
            first = newNode;
        } else {
            SLLNode<E> current = first;
            while (current.succ != null) {
                current = current.succ;
            }
            current.succ = newNode;
        }
    }

    public void insertFirst(E element) {
        SLLNode<E> newNode = new SLLNode<>(element, first);
        first = newNode;
    }

    public void delete(SLLNode<E> node) {
        if (first == null || node == null) return;

        if (first == node) {
            first = first.succ;
            return;
        }

        SLLNode<E> current = first;
        while (current.succ != null && current.succ != node) {
            current = current.succ;
        }

        if (current.succ == node) {
            current.succ = node.succ;
        }
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        SLLNode<E> current = first;
        while (current != null) {
            sb.append(current.element);
            if (current.succ != null) sb.append("->");
            current = current.succ;
        }
        return sb.toString();
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);

        int n = input.nextInt(); // Number of elements in the list
        SLL<String> list = new SLL<>();

        for (int i = 0; i < n; i++) {
            String val = input.next();
            list.insertLast(val);
        }

        int length = input.nextInt(); // Target length for the element
        System.out.println(list);

        SLLNode<String> node = list.getFirst();
        SLLNode<String> lastNode = null;

        while (node != null) {
            if (node.element.length() == length) {
                lastNode = node;
            }
            node = node.succ;
        }

        if (lastNode != null) {
            list.delete(lastNode);
            list.insertFirst(lastNode.element);
        }

        System.out.println(list);
        input.close();
    }
}



7.
Дадена е двострано поврзана листа од цели броеви. Дополнително, даден е и уште еден природен број k. Елементите во листата треба да се ротираат k пати на десно.
Влез: Во првиот ред од влезот е даден бројот на елементи во листата - N, па во следните следниот ред самите елементи одделени со празно место. На крај, во последниот ред даден е и природниот број k.
Излез: На излез треба да се испечати листата пред и после промената.
/
You are given a doubly-linked list of integers. Additionally, there is one more natural number k. You need to rotate the elements of the list k times to the right.
Input: The first number in the input is the number of integers in the list - N, then in the next line the elements are given, separated by spaces. Then, in the last line, the natural number k is given.
Output: The list before and after the transformation
For example:
Input 	

5
1 2 3 4 5
2
	
Result
1<->2<->3<->4<->5
4<->5<->1<->2<->3

4
1 3 5 7
4

Result
1<->3<->5<->7
1<->3<->5<->7

import java.util.ArrayList;
import java.util.Scanner;



class Node {
    int value;
    Node prev, next;

    public Node(int value) {
        this.value = value;
        this.prev = null;
        this.next = null;
    }
}

class DoublyLinkedList {
    private Node head, tail;

    public DoublyLinkedList() {
        this.head = null;
        this.tail = null;
    }

    // Append a new node to the end of the list
    public void append(int value) {
        Node newNode = new Node(value);
        if (head == null) {
            head = tail = newNode;
        } else {
            tail.next = newNode;
            newNode.prev = tail;
            tail = newNode;
        }
    }

    // Convert the list to a string for output
    public String toString() {
        StringBuilder result = new StringBuilder();
        Node current = head;
        while (current != null) {
            result.append(current.value);
            if (current.next != null) result.append("<->");
            current = current.next;
        }
        return result.toString();
    }

    // Rotate the list to the right by k positions
    public void rotateRight(int k) {
        if(head==null||k<0){
            return;
        }
        Node current=head;
        int length=0;
        while (current!=null){
            length++;
            current=current.next;
        }
        k=k%length;
        if (k==0) return;
        int newTailPosition=length-k;
        Node newTail=head;
        for (int i = 0; i <newTailPosition ; i++) {
            newTail=newTail.next;
        }
        Node newHead=newTail.next;

        newTail.next=null;
        newHead.prev=null;

        tail.next=head;
        head.prev=tail;
        head=newHead;
        tail=newTail;
    }
}


public class Main {
    

    public static void main(String[] args) {
   
        Scanner scanner = new java.util.Scanner(System.in);

        // Read the number of elements in the list
        int n = scanner.nextInt();
        DoublyLinkedList dll = new DoublyLinkedList();

        // Read the elements of the list
        for (int i = 0; i < n; i++) {
            int value = scanner.nextInt();
            dll.append(value);
        }

        // Read the number of rotations
        int k = scanner.nextInt();

        // Print the list before rotation
        System.out.println(dll);

        // Perform the rotation
        dll.rotateRight(k);

        // Print the list after rotation
        System.out.println(dll);

        scanner.close();
    }

}
8.
Дадена е двострано поврзана листа од цели броеви. Дополнително, даден е и уште еден природен број k. Елементите во листата треба да се ротираат k пати на лево.
Влез: Во првиот ред од влезот е даден бројот на елементи во листата - N, па во следните следниот ред самите елементи одделени со празно место. На крај, во последниот ред даден е и природниот број k.
Излез: На излез треба да се испечати листата пред и после промената.
/
You are given a doubly-linked list of integers. Additionally, there is one more natural number k. You need to rotate the elements of the list k times to the left.
Input: The first number in the input is the number of integers in the list - N, then in the next line the elements are given, separated by spaces. Then, in the last line, the natural number k is given.
Output: The list before and after the transformation
For example:
Input 	

5
1 2 3 4 5
2
Result
3<->4<->5<->1<->2

4
1 3 5 7
4
Result
1<->3<->5<->7

import java.util.Scanner;

class Node{
    int data;
    Node next,prev;
    public Node(int data){
        this.data=data;
        this.next=null;
        this.prev=null;
    }
}
class DLL{
    Node head,tail;

    public void rotateToLeft(int k){
        if (head==null||k==0) return;

        int length=0;
        Node current=head;
        while (current!=null){
            length++;
       current=current.next;
        }
        k=k%length;
        if (k==0)return;
         Node newTail = head;
        for (int i = 1; i < k; i++) {
            newTail = newTail.next;
        }
        Node newHead = newTail.next;

        
        newTail.next = null;
        newHead.prev = null;
        tail.next = head;
        head.prev = tail;
        head = newHead;
        tail = newTail;


    }
public String toString(){
        StringBuilder results=new StringBuilder();
        Node current=head;
        while (current!=null){
            results.append(current.data);
            if (current.next!=null){
                results.append("<->");
            }
            current=current.next;
        }
return results.toString();
    }
    public void append(int value) {
        Node newNode = new Node(value);
        if (head == null) {
            head = tail = newNode;
        } else {
            tail.next = newNode;
            newNode.prev = tail;
            tail = newNode;
        }
    }

}

public class RotateToLeft {
public static void main (String[] args){
    Scanner scanner=new Scanner(System.in);
    int n=scanner.nextInt();
DLL list=new DLL();
    for (int i = 0; i <n ; i++) {
        int element=scanner.nextInt();
        list.append(element);
    }
    int k=scanner.nextInt();
    list.rotateToLeft(k);
    System.out.println(list);
    scanner.close();
}
}

9.
Дадена е двострано поврзана листа од цели броеви. Дополнително, дадени се и уште еден цел број M и еден природен број k. Треба да се најде првото појавување на M во листата и тој број да се помести k места на лево.
Влез: Во првиот ред од влезот е даден бројот на елементи во листата - N, па во следните следниот ред самите елементи одделени со празно место. На крај, во последните два реда дадени се целиот број M и природниот број k.
Излез: На излез треба да се испечати листата пред и после промената.
/
You are given a doubly-linked list of integers. Additionally, there is one more integer M and a natural number k. You need to find the first occurence of M in the list and move that node k times to the left.
Input: The first number in the input is the number of integers in the list - N, then in the next line the elements are given, separated by spaces. Then, in the last two lines, the integer M and the natural number k are given.
Output: The list before and after the transformation
For example:
Input 	

5
1 2 3 4 5
3
2

Result
1<->2<->3<->4<->5
3<->1<->2<->4<->5

9
5 3 8 6 2 4 1 9 7
4
7

Result
5<->3<->8<->6<->2<->4<->1<->9<->7
5<->3<->8<->6<->2<->1<->9<->4<->7

10
1 2 3 4 5 6 7 8 9 10
11
7

Result
1<->2<->3<->4<->5<->6<->7<->8<->9<->10
Elementot ne postoi vo listata
1<->2<->3<->4<->5<->6<->7<->8<->9<->10

import java.util.Scanner;

class DLLNode<E> {
    protected E element;
    protected DLLNode<E> pred, succ;

    public DLLNode(E elem, DLLNode<E> pred, DLLNode<E> succ) {
        this.element = elem;
        this.pred = pred;
        this.succ = succ;
    }

    @Override
    public String toString() {
        return element.toString();
    }
}


public class DLL<E> {
    private DLLNode<E> first, last;

    public DLL() {
        this.first = null;
        this.last = null;
    }

    public void insertFirst(E o) {
        DLLNode<E> ins = new DLLNode<>(o, null, first);
        if (first == null)
            last = ins;
        else
            first.pred = ins;
        first = ins;
    }

    public void insertLast(E o) {
        if (first == null)
            insertFirst(o);
        else {
            DLLNode<E> ins = new DLLNode<>(o, last, null);
            last.succ = ins;
            last = ins;
        }
    }

    public void insertAfter(E o, DLLNode<E> after) {
        if (after == last) {
            insertLast(o);
            return;
        }
        DLLNode<E> ins = new DLLNode<>(o, after, after.succ);
        after.succ.pred = ins;
        after.succ = ins;
    }

    public void insertBefore(E o, DLLNode<E> before) {
        if (before == first) {
            insertFirst(o);
            return;
        }
        DLLNode<E> ins = new DLLNode<>(o, before.pred, before);
        before.pred.succ = ins;
        before.pred = ins;
    }

    public E deleteFirst() {
        if (first != null) {
            DLLNode<E> tmp = first;
            first = first.succ;
            if (first != null) first.pred = null;
            if (first == null)
                last = null;
            return tmp.element;
        } else
            return null;
    }

    public E deleteLast() {
        if (first != null) {
            if (first.succ == null)
                return deleteFirst();
            else {
                DLLNode<E> tmp = last;
                last = last.pred;
                last.succ = null;
                return tmp.element;
            }
        } else
            return null;
    }

    public E delete(DLLNode<E> node) {
        if (node == first) {
            return deleteFirst();
        }
        if (node == last) {
            return deleteLast();
        }
        node.pred.succ = node.succ;
        node.succ.pred = node.pred;
        return node.element;

    }

    public DLLNode<E> find(E o) {
        if (first != null) {
            DLLNode<E> tmp = first;
            while (!tmp.element.equals(o) && tmp.succ != null)
                tmp = tmp.succ;
            if (tmp.element.equals(o)) {
                return tmp;
            } else {
                System.out.println("Elementot ne postoi vo listata");
            }
        } else {
            System.out.println("The list is empty");
        }
        return null;
    }

    public void deleteList() {
        first = null;
        last = null;
    }

    public int getSize() {
        int listSize = 0;
        DLLNode<E> tmp = first;
        while (tmp != null) {
            listSize++;
            tmp = tmp.succ;
        }
        return listSize;
    }

    @Override
    public String toString() {
        StringBuilder ret = new StringBuilder();
        if (first != null) {
            DLLNode<E> tmp = first;
            ret.append(tmp);
            while (tmp.succ != null) {
                tmp = tmp.succ;
                ret.append("<->").append(tmp);
            }
        } else {
            ret = new StringBuilder("Empty list!!!");
        }
        return ret.toString();
    }

    public String toStringR() {
        StringBuilder ret = new StringBuilder();
        if (last != null) {
            DLLNode<E> tmp = last;
            ret.append(tmp);
            while (tmp.pred != null) {
                tmp = tmp.pred;
                ret.append("<->").append(tmp);
            }
        } else {
            ret = new StringBuilder("Empty list!!!");
        }
        return ret.toString();
    }

    public DLLNode<E> getFirst() {
        return first;
    }

    public DLLNode<E> getLast() {
        return last;
    }

    public void mirror() {
        DLLNode<E> tmp = null;
        DLLNode<E> current = first;
        last = first;
        while (current != null) {
            tmp = current.pred;
            current.pred = current.succ;
            current.succ = tmp;
            current = current.pred;
        }

        if (tmp != null && tmp.pred != null) {
            first = tmp.pred;
        }
    }

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();

        DLL<Integer> list = new DLL<>();
        for (int i = 0; i < n; i++) {
            list.insertLast(input.nextInt());
        }

        int m = input.nextInt();
        int k = input.nextInt();

        System.out.println(list);

        DLLNode<Integer> current = list.find(m);

        if (current == null) {
            System.out.println(list);
            return;
        }

        for (int i = 0; i < k; i++) {
            int value = list.delete(current);
            if (current.pred == null) {
                list.insertLast(value);
                current = list.getLast();
            } else {
                list.insertBefore(value, current.pred);
                current = list.find(m);
            }
        }

        System.out.println(list);
    }
}


10.
Дадена е двострано поврзана листа од цели броеви. Дополнително, дадени се и уште еден цел број M и еден природен број k. Треба да се најде првото појавување на M во листата и тој број да се помести k места на десно.
Влез: Во првиот ред од влезот е даден бројот на елементи во листата - N, па во следните следниот ред самите елементи одделени со празно место. На крај, во последните два реда дадени се целиот број M и природниот број k.
Излез: На излез треба да се испечати листата пред и после промената.
/
You are given a doubly-linked list of integers. Additionally, there is one more integer M and a natural number k. You need to find the first occurence of M in the list and move that node k times to the right.
Input: The first number in the input is the number of integers in the list - N, then in the next line the elements are given, separated by spaces. Then, in the last two lines, the integer M and the natural number k are given.
Output: The list before and after the transformation
For example:
Input 	

5
1 2 3 4 5
3
2

Result
1<->2<->3<->4<->5
1<->2<->4<->5<->3

9
5 3 8 6 2 4 1 9 7
4
7

Result
5<->3<->8<->6<->2<->4<->1<->9<->7
5<->3<->8<->4<->6<->2<->1<->9<->7

10
1 2 3 4 5 6 7 8 9 10
11
7

Result
1<->2<->3<->4<->5<->6<->7<->8<->9<->10
Elementot ne postoi vo listata
1<->2<->3<->4<->5<->6<->7<->8<->9<->10
import java.util.Scanner;

class DLLNode<E> {
    E element;
    DLLNode<E> pred, succ;

    public DLLNode(E element, DLLNode<E> pred, DLLNode<E> succ) {
        this.element = element;
        this.pred = pred;
        this.succ = succ;
    }
}

class DLL<E> {
    private DLLNode<E> head, tail;
    private int size;

    public DLL() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }

    public int getSize() {
        return size;
    }

    public DLLNode<E> getFirst() {
        return head;
    }

    public void insertLast(E element) {
        DLLNode<E> newNode = new DLLNode<>(element, tail, null);
        if (tail == null) {
            head = tail = newNode;
        } else {
            tail.succ = newNode;
            tail = newNode;
        }
        size++;
    }

    public void insertBefore(E element, DLLNode<E> node) {
        if (node == null) return;

        DLLNode<E> newNode = new DLLNode<>(element, node.pred, node);
        if (node.pred != null) {
            node.pred.succ = newNode;
        } else {
            head = newNode;
        }
        node.pred = newNode;
        size++;
    }

    public void insertAfter(E element, DLLNode<E> node) {
        if (node == null) return;

        DLLNode<E> newNode = new DLLNode<>(element, node, node.succ);
        if (node.succ != null) {
            node.succ.pred = newNode;
        } else {
            tail = newNode;
        }
        node.succ = newNode;
        size++;
    }

    public void delete(DLLNode<E> node) {
        if (node == null) return;

        if (node.pred != null) {
            node.pred.succ = node.succ;
        } else {
            head = node.succ;
        }

        if (node.succ != null) {
            node.succ.pred = node.pred;
        } else {
            tail = node.pred;
        }

        size--;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        DLLNode<E> current = head;
        while (current != null) {
            sb.append(current.element);
            if (current.succ != null) sb.append("<->");
            current = current.succ;
        }
        return sb.toString();
    }
}


public class Main {
    public static void func(DLL<Integer> list, int M, int k) {
        System.out.println(list);
        DLLNode<Integer> temp = list.getFirst();
        DLLNode<Integer> firstOccur = null;
        int position = 1;

        while (temp != null) {
            if (temp.element.equals(M)) {
                firstOccur = temp;
                break;
            }
            position++;
            temp = temp.succ;
        }

        if (firstOccur == null) {
            System.out.println("Elementot ne postoi vo listata");
            System.out.println(list);
        } else {
            DLLNode<Integer> newTemp = firstOccur;
            int counter = 0;

            if ((list.getSize() - position) < k) { // Start from the beginning of the list
                counter = k - (list.getSize() - position) - 1;
                temp = list.getFirst();
                while (counter != 0) {
                    temp = temp.succ;
                    counter--;
                }
                list.insertBefore(newTemp.element, temp);
            } else {
                while (counter != k) {
                    newTemp = newTemp.succ;
                    counter++;
                }
                list.insertAfter(firstOccur.element, newTemp);
            }
            list.delete(firstOccur);
            System.out.println(list);
        }
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        DLL<Integer> list = new DLL<>();

        for (int i = 0; i < n; i++) {
            list.insertLast(in.nextInt());
        }

        int M = in.nextInt();
        int k = in.nextInt();

        func(list, M, k);
    }
}



11.
Дадена е двострано поврзана листа од цели броеви. Дополнително, даден е и уште еден природен број k. Последните k елементи од листата треба да се поместат на почетокот на листата, во истиот редослед.
Влез: Во првиот ред од влезот е даден бројот на елементи во листата - N, па во следните следниот ред самите елементи одделени со празно место. На крај, во последниот ред даден е и природниот број k. (k<=N)
Излез: На излез треба да се испечати листата пред и после промената.
/
You are given a doubly-linked list of integers. Additionally, there is one more natural number k. You need to replace the last k elements of the list to the beginning of the list, in the same order.
Input: The first number in the input is the number of integers in the list - N, then in the next line the elements are given, separated by spaces. Then, in the last line, the natural number k is given. (k<=N)
Output: The list before and after the transformation
For example:
Input 	

5
1 2 3 4 5
2

Result
1<->2<->3<->4<->5
4<->5<->1<->2<->3

4
1 3 5 7
4

Result
1<->3<->5<->7
1<->3<->5<->7

import java.util.Scanner;

class DoublyLinkedListNode {
    int value;
    DoublyLinkedListNode next;
    DoublyLinkedListNode prev;

    public DoublyLinkedListNode(int value) {
        this.value = value;
        this.next = null;
        this.prev = null;
    }
}

class DoublyLinkedList {
    DoublyLinkedListNode head;
    DoublyLinkedListNode tail;

    public DoublyLinkedList() {
        this.head = null;
        this.tail = null;
    }

    // Method to append a node to the doubly linked list
    public void append(int value) {
        DoublyLinkedListNode newNode = new DoublyLinkedListNode(value);
        if (head == null) {
            head = newNode;
            tail = newNode;
        } else {
            tail.next = newNode;
            newNode.prev = tail;
            tail = newNode;
        }
    }

    // Method to print the doubly linked list
    public void printList() {
        DoublyLinkedListNode current = head;
        StringBuilder result = new StringBuilder();
        while (current != null) {
            result.append(current.value);
            if (current.next != null) {
                result.append("<->");
            }
            current = current.next;
        }
        System.out.println(result.toString());
    }

    // Method to rotate the last k elements to the front
    public void rotateLastKToFront(int k) {
        if (k == 0 || head == null) {
            return;
        }

        // Find the length of the list
        int length = 0;
        DoublyLinkedListNode current = head;
        while (current != null) {
            length++;
            current = current.next;
        }

        if (k == length) {
            return;  // No change needed if k is equal to the length of the list
        }

        // Find the (N-k)th node from the start (after which the rotation will occur)
        DoublyLinkedListNode splitNode = head;
        for (int i = 1; i < length - k ; i++) {
            splitNode = splitNode.next;
        }

        // The new head will be the (N-k+1)th node
        DoublyLinkedListNode newHead = splitNode.next;
        DoublyLinkedListNode newTail = tail;
        splitNode.next = null;
        newHead.prev = null;
        tail = splitNode;

        // Attach the last k nodes to the front
        newTail.next = head;
        head.prev = newTail;
        head = newHead;
    }
}

public class Main {
    public static void main(String[] args) {
        // Reading the input
        java.util.Scanner scanner = new java.util.Scanner(System.in);
        
        // Number of elements
        int N = scanner.nextInt();
        scanner.nextLine(); // consume the newline character
        
        // List of integers
        String[] elements = scanner.nextLine().split(" ");
        
        // The value of k
        int k = scanner.nextInt();
        
        // Creating the doubly linked list
        DoublyLinkedList dll = new DoublyLinkedList();
        for (String elem : elements) {
            dll.append(Integer.parseInt(elem));
        }
        
        // Output the original list
        dll.printList();
        
        // Rotate the last k elements to the front
        dll.rotateLastKToFront(k);
        
        // Output the transformed list
        dll.printList();
        
        scanner.close();
    }
}

12.
Дадена е двострано поврзана листа од цели броеви. Дополнително, даден е и уште еден природен број k. Потребно е првите k елементи од листата да се преместат на крај, во истиот редослед.
Влез: Во првиот ред од влезот е даден бројот на елементи во листата - N, па во следните следниот ред самите елементи одделени со празно место. На крај, во последниот ред даден е и природниот број k. (k<=N)
Излез: На излез треба да се испечати листата пред и после промената.
/
You are given a doubly-linked list of integers. Additionally, there is one more natural number k. You need to replace the first k elements of the list to the end, in the same order.
Input: The first number in the input is the number of integers in the list - N, then in the next line the elements are given, separated by spaces. Then, in the last line, the natural number k is given. (k<=N)
Output: The list before and after the transformation

For example:
Input 	

5
1 2 3 4 5
2

Result
1<->2<->3<->4<->5
3<->4<->5<->1<->2

4
1 3 5 7
4

Result
1<->3<->5<->7
1<->3<->5<->7

import java.util.Scanner;

class DoublyLinkedListNode {
    int value;
    DoublyLinkedListNode next;
    DoublyLinkedListNode prev;

    public DoublyLinkedListNode(int value) {
        this.value = value;
        this.next = null;
        this.prev = null;
    }
}

class DoublyLinkedList {
    DoublyLinkedListNode head;
    DoublyLinkedListNode tail;

    public DoublyLinkedList() {
        this.head = null;
        this.tail = null;
    }

    // Method to append a node to the doubly linked list
    public void append(int value) {
        DoublyLinkedListNode newNode = new DoublyLinkedListNode(value);
        if (head == null) {
            head = newNode;
            tail = newNode;
        } else {
            tail.next = newNode;
            newNode.prev = tail;
            tail = newNode;
        }
    }

    // Method to print the doubly linked list
    public void printList() {
        DoublyLinkedListNode current = head;
        StringBuilder result = new StringBuilder();
        while (current != null) {
            result.append(current.value);
            if (current.next != null) {
                result.append("<->");
            }
            current = current.next;
        }
        System.out.println(result.toString());
    }

    // Method to move the first k elements to the end of the list
    public void moveFirstKToEnd(int k) {
        if (k == 0 || head == null) {
            return;
        }

        // Find the length of the list
        int length = 0;
        DoublyLinkedListNode current = head;
        while (current != null) {
            length++;
            current = current.next;
        }

        if (k == length) {
            return;  // No change needed if k is equal to the length of the list
        }

        // Find the kth node (after which the rotation will occur)
        DoublyLinkedListNode splitNode = head;
        for (int i = 0; i < k - 1; i++) {
            splitNode = splitNode.next;
        }

        // The new tail will be the kth node, and the new head will be the (k+1)th node
        DoublyLinkedListNode newHead = splitNode.next;
        DoublyLinkedListNode newTail = tail;
        splitNode.next = null;
        newHead.prev = null;
        tail = splitNode;

        // Attach the first k nodes to the end of the list
        newTail.next = head;
        head.prev = newTail;
        head = newHead;
    }
}

public class Main {
    public static void main(String[] args) {
        // Reading the input
        java.util.Scanner scanner = new java.util.Scanner(System.in);
        
        // Number of elements
        int N = scanner.nextInt();
        scanner.nextLine(); // consume the newline character
        
        // List of integers
        String[] elements = scanner.nextLine().split(" ");
        
        // The value of k
        int k = scanner.nextInt();
        
        // Creating the doubly linked list
        DoublyLinkedList dll = new DoublyLinkedList();
        for (String elem : elements) {
            dll.append(Integer.parseInt(elem));
        }
        
        // Output the original list
        dll.printList();
        
        // Move the first k elements to the end
        dll.moveFirstKToEnd(k);
        
        // Output the transformed list
        dll.printList();
        
        scanner.close();
    }
}
