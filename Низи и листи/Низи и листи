1.
За дадена низа од N цели броеви, да се избришат елементите со вредност помала од просекот на сите елементи во низата. На пример за низата 1, 2, 3, 4, 5 просекот е (1 + 2 + 3 + 4 + 5) / 5 = 15 / 5 = 3, 
што значи треба да се избришат елементите 1 и 2, што значи низата после оваа трансформација ќе биде 3, 4, 5.
Влез: Првиот број од влезот е бројот на елементи во низата N, а потоа во следниот ред се дадени самите елементи одделени со празно место.
Излез: Низата пред и после направената трансформација.

/

For a given array with N integers, all the elements that are lower than the average of the whole array need to be deleted. For example for the array 1, 2, 3, 4, 5 the average is (1 + 2 + 3 + 4 + 5) / 5 = 15 / 5 = 3 which means that the elements 1 and 2 should be deleted, so the array after the transformation will be 3, 4, 5.
Input: The first number in the input is the number of integers in the array N, then in the next line the elements are given, separated by spaces.

Output: The array before and after the transformation.

For example:
Input 	
5
1 2 3 4 5

Result
{1,2,3,4,5}
{3,4,5}
PRVO RESENIE:
import java.util.Scanner;
public class Main {
    static int prosek(int [] array,int n){
        float sum=0;
        for (int i = 0; i <n ; i++) {
            sum+=array[i];
        }
        int average=Math.round(sum/n);
        return average;
    }
    public static void main(String[] args) {
Scanner scanner=new Scanner(System.in);
int n=scanner.nextInt();
int[] array=new int[n];
        for (int i = 0; i < n; i++) {
            array[i]=scanner.nextInt();
        }
        System.out.print("{");
        for (int i = 0; i < n; i++) {
            System.out.print(array[i]);
            if (i<n-1) System.out.print(",");
        }
        System.out.print("}");

        int average=prosek(array,n);
        ArrayList<Integer> newArray=new ArrayList<>();
        for (int i = 0; i <n ; i++) {
            if (array[i]>=average){
                newArray.add(array[i]);
            }
        }
        System.out.println();
        System.out.print("{");
        for (int i = 0; i < newArray.size(); i++) {
            System.out.print(newArray.get(i));
            if (i<newArray.size()-1) System.out.print(",");
        }
        System.out.print("}");
    }


}

DRUGO RESENIE:

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class DeleteInArray {
    public static void main( String[] args){
        Scanner scanner=new Scanner(System.in);
        int n=scanner.nextInt();
        int[] array=new int[n];
        for (int i = 0; i < n; i++) {
            array[i]=scanner.nextInt();
        }
        double sum=0;
        for (int num:array){
            sum+=num;
        }
        double avg=sum/n;
        List<Integer>filteredArray=new ArrayList<>();
        for (int num:array){
            if (num>=avg){
                filteredArray.add(num);
            }
        }
        System.out.print("{");
        for (int i = 0; i <n ; i++) {
            System.out.print(array[i]);
            if (i<array.length-1){
                System.out.print(",");
            }
        }
        System.out.print("}");
        System.out.println();

        System.out.print("{");
        for (int i = 0; i <filteredArray.size(); i++) {
            System.out.print(filteredArray.get(i));
            if (i<filteredArray.size()-1){
                System.out.print(",");
            }
        }
        System.out.print("}");
    }

}

2.
Дадена е еднострана поврзана листа чии што јазли содржат по еден String. Дополнително, даден е и уште еден природен број L. Од дадената листа потребно е да се избрише секој јазел којшто содржи String со должина помала од L.
Влез: Во првиот ред од влезот е даден бројот на елементи во листата - N, па во следните N редови се дадени самите елементи (String-ови) од листата. На крај, во последниот ред е даден бројот L. 
Излез: На излез треба да се испечати листата пред и после промената.
/
You are given a single linked list with String nodes. Additionally, you are given one more integer L. You need to delete every node from the list that contains a String with less than L characters.
Input: In the first line from the input the number of elements in the list is given - N, and then in the next N lines the elements themselves. In the last line, the integer L is given.
Output: The list before and after the transformation

For example:
Input 	

3
Sky
Blue
Cloud
5

Result
Sky->Blue->Cloud
Cloud


public class SLLDeleteLessThanN {

    public static class SLLNode<E> {
        E element;
        SLLNode<E> succ;

        public SLLNode(E element, SLLNode<E> succ) {
            this.element = element;
            this.succ = succ;
        }
    }

    public static class SLL<E> {
        SLLNode<E> first;

        public void insertFirst(E o) {
            SLLNode<E> newNode = new SLLNode<>(o, first);
            first = newNode;
        }

        public void insertLast(E o) {
            if (first != null) {
                SLLNode<E> tmp = first;
                while (tmp.succ != null)
                    tmp = tmp.succ;
                tmp.succ = new SLLNode<>(o, null);
            } else {
                insertFirst(o);
            }
        }

        SLLNode<E> getFirst() {
            return first;
        }

        public void deleteLessThanL(int L) {
           
            while (first != null && ((String) first.element).length() < L) {
                first = first.succ;
            }

           
            SLLNode<E> current = first;
            while (current != null && current.succ != null) {
                if (((String) current.succ.element).length() < L) {
                    current.succ = current.succ.succ; // Skip the node
                } else {
                    current = current.succ; // Move to the next node
                }
            }
        }

        public void printList() {
            SLLNode<E> current = first;
            while (current != null) {
                System.out.print(current.element);
                if (current.succ != null) {
                    System.out.print("->");
                }
                current = current.succ;
            }
            
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int N = scanner.nextInt();
        SLL<String> list = new SLL<>();

        for (int i = 0; i < N; i++) {
            list.insertLast(scanner.next());
        }

        int L = scanner.nextInt();

      
        list.printList();

        list.deleteLessThanL(L);
System.out.println();
        list.printList();

        scanner.close();
    }
}
3.
Дадена е еднострана поврзана листа чии што јазли содржат по еден String. Дополнително, даден е и уште еден природен број L. Во дадената листа после секој јазол којшто содржи String со должина L да се вметне нов јазол со
вредност "Target".
Влез: Во првиот ред од влезот е даден бројот на елементи во листата - N, па во следните N редови се дадени самите елементи (String-ови) од листата. На крај, во последниот ред е даден бројот L. 
Излез: На излез треба да се испечати листата пред и после промената.
/

You are given a single linked list with String nodes. Additionally, you are given one more integer L. You need to insert a new node with value "Target" after each node that contains a String with exactly L characters in the list.
Input: In the first line from the input the number of elements in the list is given - N, and then in the next N lines the elements themselves. In the last line, the integer L is given.
Output: The list before and after the transformation
For example:
Input 	

3
Sky
Blue
Cloud
5

Result
Sky->Blue->Cloud
Sky->Blue->Cloud->Target

import java.util.Scanner;

public class SLLInsertAfterTarget {

    public static class SLLNode<E> {
        E element;
        SLLNode<E> succ;

        public SLLNode(E element, SLLNode<E> succ) {
            this.element = element;
            this.succ = succ;
        }
    }

    public static class SLL<E> {
        SLLNode<E> first;

        public void insertLast(E o) {
            if (first != null) {
                SLLNode<E> tmp = first;
                while (tmp.succ != null)
                    tmp = tmp.succ;
                tmp.succ = new SLLNode<>(o, null);
            } else {
                first = new SLLNode<>(o, null);
            }
        }

        public void insertAfterTarget(E target, int L) {
            SLLNode<E> current = first;
            while (current != null) {
                if (((String) current.element).length() == L) {
                    SLLNode<E> newNode = new SLLNode<>(target, current.succ);
                    current.succ = newNode;
                    current = newNode.succ; // Move past the new node
                } else {
                    current = current.succ;
                }
            }
        }

        public void printList() {
            SLLNode<E> current = first;
            while (current != null) {
                System.out.print(current.element);
                if (current.succ != null) {
                    System.out.print("->");
                }
                current = current.succ;
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the number of elements in the list
        int N = scanner.nextInt();
        SLL<String> list = new SLL<>();

        // Read the elements of the list
        for (int i = 0; i < N; i++) {
            list.insertLast(scanner.next());
        }

        // Read the value of L
        int L = scanner.nextInt();

        // Print the list before transformation
        list.printList();

        // Perform the transformation
        list.insertAfterTarget("Target", L);

        // Print the list after transformation
        list.printList();

        scanner.close();
    }
}
4.
Дадена е еднострана поврзана листа чии што јазли содржат по еден String. Дополнително, даден е и уште еден природен број L. Во дадената листа потребно е сите јазли коишто содржат String со должина L да се
поместат на крај на листата, задржувајќи го и оригиналниот распоред на елементите.
Влез: Во првиот ред од влезот е даден бројот на елементи во листата - N, па во следните N редови се дадени самите елементи (String-ови) од листата. На крај, во последниот ред е даден бројот L. 
Излез: На излез треба да се испечати листата пред и после промената.
/

You are given a single linked list with String nodes. Additionally, you are given one more integer L. You need to move all nodes from the list that contain a String with exactly L characters to the end of the list, keeping the original order of elements as well.
Input: In the first line from the input the number of elements in the list is given - N, and then in the next N lines the elements themselves. In the last line, the integer L is given.
Output: The list before and after the transformation
For example:
Input 	

3
Sky
Blue
Cloud
5

	
Result
Sky->Blue->Cloud
Sky->Blue->Cloud

4
Apple
Banana
Pear
Watermelon
6

Result
Apple->Banana->Pear->Watermelon
Apple->Pear->Watermelon->Banana
import java.util.ArrayList;
import java.util.Scanner;





public class Main {
    public static class Node {
        String element;
        Node succ;

        public Node(String element) {
            this.element = element;
            this.succ = null;
        }
    }



    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        // Read input
        int n = sc.nextInt();  // Number of elements in the list
        sc.nextLine();  // Consume newline
        Node head = null, tail = null;

        for (int i = 0; i < n; i++) {
            String data = sc.nextLine();
            Node newNode = new Node(data);
            if (head == null) {
                head = newNode;
                tail = head;
            } else {
                tail.succ = newNode;
                tail = newNode;
            }
        }

        int l = sc.nextInt();  // The integer L


        printList(head);

        // Transform the list
        head = transformList(head, l);

        printList(head);

        sc.close();
    }
    private static Node transformList(Node head, int l){
        if (head==null){
            return null ;
        }

        Node dummyHead=new Node("");
dummyHead.succ=head;
        Node current=dummyHead;

        Node tmpHead=new Node("");
        Node tmpTail=tmpHead;

while (current!=null){
    if (current.succ.element.length()==l){
Node moveNode=current.succ;
current.succ=current.succ.succ;
moveNode.succ=null;
tmpTail.succ=moveNode;
tmpTail=moveNode;
    }else{
        current=current.succ;
    }
}
current.succ=dummyHead.succ;
return dummyHead.succ;
    }
    private static void printList(Node head) {
        Node current = head;
        while (current != null) {
            System.out.print(current.succ + (current.succ != null ? "->" : ""));
            current = current.succ;
        }
        System.out.println();
    }
}

5.
Дадена е двострано поврзана листа од цели броеви. Дополнително, даден е и уште еден природен број k. Елементите во листата треба да се ротираат k пати на десно.
Влез: Во првиот ред од влезот е даден бројот на елементи во листата - N, па во следните следниот ред самите елементи одделени со празно место. На крај, во последниот ред даден е и природниот број k.
Излез: На излез треба да се испечати листата пред и после промената.
/
You are given a doubly-linked list of integers. Additionally, there is one more natural number k. You need to rotate the elements of the list k times to the right.
Input: The first number in the input is the number of integers in the list - N, then in the next line the elements are given, separated by spaces. Then, in the last line, the natural number k is given.
Output: The list before and after the transformation
For example:
Input 	

5
1 2 3 4 5
2
	
Result
1<->2<->3<->4<->5
4<->5<->1<->2<->3

4
1 3 5 7
4

Result
1<->3<->5<->7
1<->3<->5<->7

import java.util.ArrayList;
import java.util.Scanner;



class Node {
    int value;
    Node prev, next;

    public Node(int value) {
        this.value = value;
        this.prev = null;
        this.next = null;
    }
}

class DoublyLinkedList {
    private Node head, tail;

    public DoublyLinkedList() {
        this.head = null;
        this.tail = null;
    }

    // Append a new node to the end of the list
    public void append(int value) {
        Node newNode = new Node(value);
        if (head == null) {
            head = tail = newNode;
        } else {
            tail.next = newNode;
            newNode.prev = tail;
            tail = newNode;
        }
    }

    // Convert the list to a string for output
    public String toString() {
        StringBuilder result = new StringBuilder();
        Node current = head;
        while (current != null) {
            result.append(current.value);
            if (current.next != null) result.append("<->");
            current = current.next;
        }
        return result.toString();
    }

    // Rotate the list to the right by k positions
    public void rotateRight(int k) {
        if(head==null||k<0){
            return;
        }
        Node current=head;
        int length=0;
        while (current!=null){
            length++;
            current=current.next;
        }
        k=k%length;
        if (k==0) return;
        int newTailPosition=length-k;
        Node newTail=head;
        for (int i = 0; i <newTailPosition ; i++) {
            newTail=newTail.next;
        }
        Node newHead=newTail.next;

        newTail.next=null;
        newHead.prev=null;

        tail.next=head;
        head.prev=tail;
        head=newHead;
        tail=newTail;
    }
}


public class Main {
    

    public static void main(String[] args) {
   
        Scanner scanner = new java.util.Scanner(System.in);

        // Read the number of elements in the list
        int n = scanner.nextInt();
        DoublyLinkedList dll = new DoublyLinkedList();

        // Read the elements of the list
        for (int i = 0; i < n; i++) {
            int value = scanner.nextInt();
            dll.append(value);
        }

        // Read the number of rotations
        int k = scanner.nextInt();

        // Print the list before rotation
        System.out.println(dll);

        // Perform the rotation
        dll.rotateRight(k);

        // Print the list after rotation
        System.out.println(dll);

        scanner.close();
    }

}
6.
Дадена е двострано поврзана листа од цели броеви. Дополнително, даден е и уште еден природен број k. Елементите во листата треба да се ротираат k пати на лево.
Влез: Во првиот ред од влезот е даден бројот на елементи во листата - N, па во следните следниот ред самите елементи одделени со празно место. На крај, во последниот ред даден е и природниот број k.
Излез: На излез треба да се испечати листата пред и после промената.
/
You are given a doubly-linked list of integers. Additionally, there is one more natural number k. You need to rotate the elements of the list k times to the left.
Input: The first number in the input is the number of integers in the list - N, then in the next line the elements are given, separated by spaces. Then, in the last line, the natural number k is given.
Output: The list before and after the transformation
For example:
Input 	

5
1 2 3 4 5
2
Result
3<->4<->5<->1<->2

4
1 3 5 7
4
Result
1<->3<->5<->7

import java.util.Scanner;

class Node{
    int data;
    Node next,prev;
    public Node(int data){
        this.data=data;
        this.next=null;
        this.prev=null;
    }
}
class DLL{
    Node head,tail;

    public void rotateToLeft(int k){
        if (head==null||k==0) return;

        int length=0;
        Node current=head;
        while (current!=null){
            length++;
       current=current.next;
        }
        k=k%length;
        if (k==0)return;
         Node newTail = head;
        for (int i = 1; i < k; i++) {
            newTail = newTail.next;
        }
        Node newHead = newTail.next;

        
        newTail.next = null;
        newHead.prev = null;
        tail.next = head;
        head.prev = tail;
        head = newHead;
        tail = newTail;


    }
public String toString(){
        StringBuilder results=new StringBuilder();
        Node current=head;
        while (current!=null){
            results.append(current.data);
            if (current.next!=null){
                results.append("<->");
            }
            current=current.next;
        }
return results.toString();
    }
    public void append(int value) {
        Node newNode = new Node(value);
        if (head == null) {
            head = tail = newNode;
        } else {
            tail.next = newNode;
            newNode.prev = tail;
            tail = newNode;
        }
    }

}

public class RotateToLeft {
public static void main (String[] args){
    Scanner scanner=new Scanner(System.in);
    int n=scanner.nextInt();
DLL list=new DLL();
    for (int i = 0; i <n ; i++) {
        int element=scanner.nextInt();
        list.append(element);
    }
    int k=scanner.nextInt();
    list.rotateToLeft(k);
    System.out.println(list);
    scanner.close();
}
}

7.
Дадена е двострано поврзана листа од цели броеви. Дополнително, даден е и уште еден природен број k. Последните k елементи од листата треба да се поместат на почетокот на листата, во истиот редослед.
Влез: Во првиот ред од влезот е даден бројот на елементи во листата - N, па во следните следниот ред самите елементи одделени со празно место. На крај, во последниот ред даден е и природниот број k. (k<=N)
Излез: На излез треба да се испечати листата пред и после промената.
/
You are given a doubly-linked list of integers. Additionally, there is one more natural number k. You need to replace the last k elements of the list to the beginning of the list, in the same order.
Input: The first number in the input is the number of integers in the list - N, then in the next line the elements are given, separated by spaces. Then, in the last line, the natural number k is given. (k<=N)
Output: The list before and after the transformation
For example:
Input 	

5
1 2 3 4 5
2

Result
1<->2<->3<->4<->5
4<->5<->1<->2<->3

4
1 3 5 7
4

Result
1<->3<->5<->7
1<->3<->5<->7

import java.util.Scanner;

class DoublyLinkedListNode {
    int value;
    DoublyLinkedListNode next;
    DoublyLinkedListNode prev;

    public DoublyLinkedListNode(int value) {
        this.value = value;
        this.next = null;
        this.prev = null;
    }
}

class DoublyLinkedList {
    DoublyLinkedListNode head;
    DoublyLinkedListNode tail;

    public DoublyLinkedList() {
        this.head = null;
        this.tail = null;
    }

    // Method to append a node to the doubly linked list
    public void append(int value) {
        DoublyLinkedListNode newNode = new DoublyLinkedListNode(value);
        if (head == null) {
            head = newNode;
            tail = newNode;
        } else {
            tail.next = newNode;
            newNode.prev = tail;
            tail = newNode;
        }
    }

    // Method to print the doubly linked list
    public void printList() {
        DoublyLinkedListNode current = head;
        StringBuilder result = new StringBuilder();
        while (current != null) {
            result.append(current.value);
            if (current.next != null) {
                result.append("<->");
            }
            current = current.next;
        }
        System.out.println(result.toString());
    }

    // Method to rotate the last k elements to the front
    public void rotateLastKToFront(int k) {
        if (k == 0 || head == null) {
            return;
        }

        // Find the length of the list
        int length = 0;
        DoublyLinkedListNode current = head;
        while (current != null) {
            length++;
            current = current.next;
        }

        if (k == length) {
            return;  // No change needed if k is equal to the length of the list
        }

        // Find the (N-k)th node from the start (after which the rotation will occur)
        DoublyLinkedListNode splitNode = head;
        for (int i = 1; i < length - k ; i++) {
            splitNode = splitNode.next;
        }

        // The new head will be the (N-k+1)th node
        DoublyLinkedListNode newHead = splitNode.next;
        DoublyLinkedListNode newTail = tail;
        splitNode.next = null;
        newHead.prev = null;
        tail = splitNode;

        // Attach the last k nodes to the front
        newTail.next = head;
        head.prev = newTail;
        head = newHead;
    }
}

public class Main {
    public static void main(String[] args) {
        // Reading the input
        java.util.Scanner scanner = new java.util.Scanner(System.in);
        
        // Number of elements
        int N = scanner.nextInt();
        scanner.nextLine(); // consume the newline character
        
        // List of integers
        String[] elements = scanner.nextLine().split(" ");
        
        // The value of k
        int k = scanner.nextInt();
        
        // Creating the doubly linked list
        DoublyLinkedList dll = new DoublyLinkedList();
        for (String elem : elements) {
            dll.append(Integer.parseInt(elem));
        }
        
        // Output the original list
        dll.printList();
        
        // Rotate the last k elements to the front
        dll.rotateLastKToFront(k);
        
        // Output the transformed list
        dll.printList();
        
        scanner.close();
    }
}

8.
Дадена е двострано поврзана листа од цели броеви. Дополнително, даден е и уште еден природен број k. Потребно е првите k елементи од листата да се преместат на крај, во истиот редослед.
Влез: Во првиот ред од влезот е даден бројот на елементи во листата - N, па во следните следниот ред самите елементи одделени со празно место. На крај, во последниот ред даден е и природниот број k. (k<=N)
Излез: На излез треба да се испечати листата пред и после промената.
/
You are given a doubly-linked list of integers. Additionally, there is one more natural number k. You need to replace the first k elements of the list to the end, in the same order.
Input: The first number in the input is the number of integers in the list - N, then in the next line the elements are given, separated by spaces. Then, in the last line, the natural number k is given. (k<=N)
Output: The list before and after the transformation

For example:
Input 	

5
1 2 3 4 5
2

Result
1<->2<->3<->4<->5
3<->4<->5<->1<->2

4
1 3 5 7
4

Result
1<->3<->5<->7
1<->3<->5<->7

import java.util.Scanner;

class DoublyLinkedListNode {
    int value;
    DoublyLinkedListNode next;
    DoublyLinkedListNode prev;

    public DoublyLinkedListNode(int value) {
        this.value = value;
        this.next = null;
        this.prev = null;
    }
}

class DoublyLinkedList {
    DoublyLinkedListNode head;
    DoublyLinkedListNode tail;

    public DoublyLinkedList() {
        this.head = null;
        this.tail = null;
    }

    // Method to append a node to the doubly linked list
    public void append(int value) {
        DoublyLinkedListNode newNode = new DoublyLinkedListNode(value);
        if (head == null) {
            head = newNode;
            tail = newNode;
        } else {
            tail.next = newNode;
            newNode.prev = tail;
            tail = newNode;
        }
    }

    // Method to print the doubly linked list
    public void printList() {
        DoublyLinkedListNode current = head;
        StringBuilder result = new StringBuilder();
        while (current != null) {
            result.append(current.value);
            if (current.next != null) {
                result.append("<->");
            }
            current = current.next;
        }
        System.out.println(result.toString());
    }

    // Method to move the first k elements to the end of the list
    public void moveFirstKToEnd(int k) {
        if (k == 0 || head == null) {
            return;
        }

        // Find the length of the list
        int length = 0;
        DoublyLinkedListNode current = head;
        while (current != null) {
            length++;
            current = current.next;
        }

        if (k == length) {
            return;  // No change needed if k is equal to the length of the list
        }

        // Find the kth node (after which the rotation will occur)
        DoublyLinkedListNode splitNode = head;
        for (int i = 0; i < k - 1; i++) {
            splitNode = splitNode.next;
        }

        // The new tail will be the kth node, and the new head will be the (k+1)th node
        DoublyLinkedListNode newHead = splitNode.next;
        DoublyLinkedListNode newTail = tail;
        splitNode.next = null;
        newHead.prev = null;
        tail = splitNode;

        // Attach the first k nodes to the end of the list
        newTail.next = head;
        head.prev = newTail;
        head = newHead;
    }
}

public class Main {
    public static void main(String[] args) {
        // Reading the input
        java.util.Scanner scanner = new java.util.Scanner(System.in);
        
        // Number of elements
        int N = scanner.nextInt();
        scanner.nextLine(); // consume the newline character
        
        // List of integers
        String[] elements = scanner.nextLine().split(" ");
        
        // The value of k
        int k = scanner.nextInt();
        
        // Creating the doubly linked list
        DoublyLinkedList dll = new DoublyLinkedList();
        for (String elem : elements) {
            dll.append(Integer.parseInt(elem));
        }
        
        // Output the original list
        dll.printList();
        
        // Move the first k elements to the end
        dll.moveFirstKToEnd(k);
        
        // Output the transformed list
        dll.printList();
        
        scanner.close();
    }
}
